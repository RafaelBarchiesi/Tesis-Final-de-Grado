# -*- coding: utf-8 -*-
"""RIGI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H0bPmi5Opj0v0JMuUv2jRWlgSeTmLdiL

# **Los beneficios esperados del RIGI a partir del análisis de la teoría económica**

## **Conectamos con Google Drive e Importamos las librerias necesarias**
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import sympy as sp
import numpy as np
from scipy.optimize import fsolve
import seaborn as sns
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

"""Definimos las variabes y le damos valores a los parámetros que necesitemos.

## **Cournot con 2 firmas**

Primero se busca encontrar el equilibrio para dos firmas simétricas con costos marginales cuadráticos las cuales compiten a lo Cournot. De esta forma se tratá de modelizar como se encuentra un determinado mercado antes de la incorporación del RIGI.

Le damos valores determinados a las variables $a$, $a_0$, $a_1$ y $a_2$, y al resto de las variables no se les asignará un valor determinado, más adelante se explicará que es lo que se hará con estas como son $a_3$ y $b$.
"""

q = sp.symbols('q')
b = sp.symbols('b')

a = 100
a0 = 5
a1 = 2.5
a2 = 1.5

a3 = sp.symbols('a3')
n = sp.symbols('n')
qL = sp.symbols('qL')
qS = sp.symbols('qS')
qi = sp.symbols('qi')
qj = sp.symbols('qj')

"""Determinamos el ingreso de la firma $i$."""

ingreso_C_2 = (a-b*(qi+qj))*qi
ingreso_C_2

"""Determinamos los costos de esta misma firma."""

costo_C_2 = a3*qi**3 + a2*qi**2 + a1*qi + a0
costo_C_2

"""Y consecuentemente, determinamos el beneficio de la misma, el cual es el que se ve aquí debajo"""

beneficio_C_2 = ingreso_C_2 - costo_C_2
beneficio_C_2

"""Para poder determinar el equilibrio de este mercado, debemos optimizar el beneficio de esta firma, es por ello que se procede a derivar el beneficio anterior para así encontrar un máximo."""

beneficio_C_2_D = sp.diff(beneficio_C_2,qi)
beneficio_C_2_D

"""Al estar la ecuacion anterior, automáticamente, igualada a cero, se procede a despejar la variable $q_i$ para obtener la función de reacción de la firma $i$ con respecto a cambios en cantidades que pueda efectuar la firma $j$."""

f_reaccion_C = sp.solve(beneficio_C_2_D, qi)
f_reaccion_C = f_reaccion_C[1] # Seleccionamos la raiz positiva
f_reaccion_C

"""Al ser ambas firmas simétricas, se podemos remplazar la cantidad $q_j$ por la cantidad $q_i$ y de esta forma determinar la cantidad óptima que llevará cada firma al mercado, que ambas firmas (al ser simétricas) llevaran la misma cantidad al mercado."""

q_optima = f_reaccion_C.subs('qj', 'qi')
q_optima = q_optima - qi #Le restamos qi a la ecuación como método para que la variable qi figure realmente en la ecuación
q_optima

"""Despejando la variable $q_i$ obtenemos la cantidad óptima que llevará al mercado tanto la empres $i$ como la emrpesa $j$."""

q_optima_despejada = sp.solve(q_optima, qi)
q_optima_despejada  = q_optima_despejada[1]
q_optima_despejada

"""Obtenemos la segunda derivada del beneficio de la empresa $i$ que compite a lo Cournot."""

beneficio_C_2_DD = sp.diff(beneficio_C_2_D, qi)
beneficio_C_2_DD

"""Se ha implementado un bucle que calcula las cantidades de equilibrio correspondientes para un rango específico de valores de $a_3$ y de $b$. Esto permite analizar las distintas soluciones obtenidas en función de dichos parámetros.

### **Primer BUCLE**

El parámetro $a_3$ tomará valores en el rango $[0.1, 5)$ con incrementos de $0.1$ y el parámetro $b$ tomará valores en el rango $[50, 200)$ con incrementos de $5$.
"""

import numpy as np
import pandas as pd

resultados_cournot = []

for a3 in np.arange(0.1, 5, 0.1):
    for b in np.arange(50, 200, 5):
        # Calcula la solución óptima para la combinación actual de a3 y b
        q_optima = q_optima_despejada.subs('a3', a3).subs('b', b)

        # Filtra la solución: debe ser real, positiva, y el beneficio modificado debe ser negativo o cero
        beneficio_C_2_DD_mod = beneficio_C_2_DD.subs('a3', a3).subs('b', b).subs('qi', q_optima)

        if q_optima >= 0 and q_optima.is_real and beneficio_C_2_DD_mod <= 0:
            # Cálculos adicionales para la solución válida
            cantidad_total_C = 2 * q_optima
            beneficio_cournot = beneficio_C_2.subs('a3', a3).subs('b', b).subs('qi', q_optima).subs('qj', q_optima)
            precio_C = a - b * cantidad_total_C
            excedente_C = ((a - precio_C) * cantidad_total_C) / 2
            beneficio_social_C = beneficio_cournot * 2 + excedente_C

            # Almacena el resultado en un diccionario
            fila_resultadoCournot = {
                'valor_a3': a3,
                'valor_b': b,
                'Cantidad Individual': q_optima,
                'Cantidad Total': cantidad_total_C,
                'Beneficio Individual': beneficio_cournot,
                'Precio': precio_C,
                'Excedente Consumidor': excedente_C,
                'Beneficio Social': beneficio_social_C
            }

            # Agrega el diccionario a la lista de resultados
            resultados_cournot.append(fila_resultadoCournot)

# Crea el DataFrame con los resultados
df_resultados_cournot_PB = pd.DataFrame(resultados_cournot)
df_resultados_cournot_PB

"""Debido a la demora que puede occaionar la ejecución del código, se exportará cada una de las iteraciones a un archivo excel para luego ser importadas directamente."""

df_resultados_cournot_PB.to_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/cournot_PB_a3(0.1-5-0.1)_b(50-200-5).xlsx')

"""### **Segundo BUCLE**

El parámetro $a_3$ tomará valores en el rango $[5, 10)$ con incrementos de $0.1$ y el parámetro $b$ tomará valores en el rango $[5, 100)$ con incrementos de $5$.
"""

import numpy as np
import pandas as pd

resultados_cournot = []

for a3 in np.arange(5, 10, 0.1):
    for b in np.arange(5, 100, 5):
        # Calcula la solución óptima para la combinación actual de a3 y b
        q_optima = q_optima_despejada.subs('a3', a3).subs('b', b)

        # Filtra la solución: debe ser real, positiva, y el beneficio modificado debe ser negativo o cero
        beneficio_C_2_DD_mod = beneficio_C_2_DD.subs('a3', a3).subs('b', b).subs('qi', q_optima)

        if q_optima >= 0 and q_optima.is_real and beneficio_C_2_DD_mod <= 0:
            # Cálculos adicionales para la solución válida
            cantidad_total_C = 2 * q_optima
            beneficio_cournot = beneficio_C_2.subs('a3', a3).subs('b', b).subs('qi', q_optima).subs('qj', q_optima)
            precio_C = a - b * cantidad_total_C
            excedente_C = ((a - precio_C) * cantidad_total_C) / 2
            beneficio_social_C = beneficio_cournot * 2 + excedente_C

            # Almacena el resultado en un diccionario
            fila_resultadoCournot = {
                'valor_a3': a3,
                'valor_b': b,
                'Cantidad Individual': q_optima,
                'Cantidad Total': cantidad_total_C,
                'Beneficio Individual': beneficio_cournot,
                'Precio': precio_C,
                'Excedente Consumidor': excedente_C,
                'Beneficio Social': beneficio_social_C
            }

            # Agrega el diccionario a la lista de resultados
            resultados_cournot.append(fila_resultadoCournot)

# Crea el DataFrame con los resultados
df_resultados_cournot_SB = pd.DataFrame(resultados_cournot)
df_resultados_cournot_SB

df_resultados_cournot_SB.to_excel('/content/drive/MyDrive/TESIS/EXCEL/cournot_SB_a3(5-10-0.1)_b(5-100-5).xlsx')

"""### **Tercer Bucle**

El parámetro $a_3$ tomará valores en el rango $[100, 150)$ con incrementos de $0.1$ y el parámetro $b$ tomará valores en el rango $[1000, 10000)$ con incrementos de $20$.
"""

resultados_cournot = []

for a3 in np.arange(100, 150, 0.5):
    for b in np.arange(1000, 1200, 10):
        # Calcula la solución óptima para la combinación actual de a3 y b
        q_optima = q_optima_despejada.subs('a3', a3).subs('b', b)

        # Filtra la solución: debe ser real, positiva, y el beneficio modificado debe ser negativo o cero
        beneficio_C_2_DD_mod = beneficio_C_2_DD.subs('a3', a3).subs('b', b).subs('qi', q_optima)

        if q_optima >= 0 and q_optima.is_real and beneficio_C_2_DD_mod <= 0:
            # Cálculos adicionales para la solución válida
            cantidad_total_C = 2 * q_optima
            beneficio_cournot = beneficio_C_2.subs('a3', a3).subs('b', b).subs('qi', q_optima).subs('qj', q_optima)
            precio_C = a - b * cantidad_total_C
            excedente_C = ((a - precio_C) * cantidad_total_C) / 2
            beneficio_social_C = beneficio_cournot * 2 + excedente_C

            # Almacena el resultado en un diccionario
            fila_resultadoCournot = {
                'valor_a3': a3,
                'valor_b': b,
                'Cantidad Individual': q_optima,
                'Cantidad Total': cantidad_total_C,
                'Beneficio Individual': beneficio_cournot,
                'Precio': precio_C,
                'Excedente Consumidor': excedente_C,
                'Beneficio Social': beneficio_social_C
            }

            # Agrega el diccionario a la lista de resultados
            resultados_cournot.append(fila_resultadoCournot)

# Crea el DataFrame con los resultados
df_resultados_cournot_TB = pd.DataFrame(resultados_cournot)
df_resultados_cournot_TB

df_resultados_cournot_TB.to_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/cournot_3B_a3(100-150-0.1)_b(1000-1200-10).xlsx')

"""## **Stackelberg con 2 Firmas**

Ahora, lo que se busca en esta sección
"""

ingreso_S_2 = (a-b*(qL+qS))*qS

costo_S_2 = a3*qS**3 + a2*qS**2 + a1*qS + a0

beneficio_S_2 = ingreso_S_2 - costo_S_2
beneficio_S_2

beneficio_S_2_D = sp.diff(beneficio_S_2,qS)
beneficio_S_2_D

f_reaccion_S = sp.solve(beneficio_S_2_D, qS)
f_reaccion_S = f_reaccion_S[1]
f_reaccion_S

ingreso_L_2 = (a-b*(qS+qL))*qL
costo_L_2 = a3*qL**3 + a2*qL**2 + a1*qL + a0
beneficio_L_2 = ingreso_L_2 - costo_L_2
beneficio_L_2

beneficio_L_2_reemp = beneficio_L_2.subs('qS',f_reaccion_S)
beneficio_L_2_reemp

beneficio_L_2_reemp = beneficio_L_2.subs('qS',f_reaccion_S)

beneficio_L_2_reemp_D = sp.diff(beneficio_L_2_reemp, qL)
beneficio_L_2_reemp_D

beneficio_L_2_reemp_DD = sp.diff(beneficio_L_2_reemp_D, qL)
beneficio_L_2_reemp_DD

"""Vamos a hacer un bucle donde le vamos a ir dando valores a `a3` entre 0.2 y 6, y a su vez a `b` entre 0.2 y 4.

### **PRIMER BUCLE**

El parámetro $a_3$ tomará valores en el rango $[0.1, 5)$ con incrementos de $0.1$ y el parámetro $b$ tomará valores en el rango $[50, 200)$ con incrementos de $5$.
"""

resultados_stackelberg = []

for a3 in np.arange(0.1, 5, 0.1):
  for b in np.arange(50, 200, 5):

      beneficio_L_2_reemp_D_mod = beneficio_L_2_reemp_D.subs('a3', a3).subs('b', b)
      soluciones = sp.solve(beneficio_L_2_reemp_D_mod, qL)
      #print(soluciones)

      for solucion in soluciones:

        beneficio_L_2_reemp_DD_mod = beneficio_L_2_reemp_DD.subs('a3', a3).subs('b', b).subs('qL',solucion)

        if solucion < 0:
          soluciones.remove(solucion)

        elif solucion.is_real == False:
          soluciones.remove(solucion)

        elif beneficio_L_2_reemp_DD_mod > 0:
          soluciones.remove(solucion)

      cantidades_seguidora = []
      beneficios_lider = []
      beneficios_seguidora = []
      cantidades_total = []
      precios = []
      excedentes = []
      beneficios_sociales = []

      for sol in soluciones:
        q_seguidora = f_reaccion_S.subs('a3', a3).subs('b', b).subs('qL',sol)
        cantidades_seguidora.append(q_seguidora)
        beneficio_lider = beneficio_L_2_reemp.subs('a3', a3).subs('b', b).subs('qL',sol)
        beneficios_lider.append(beneficio_lider)
        beneficio_seguidora = beneficio_S_2.subs('a3', a3).subs('b', b).subs('qL',sol).subs('qS', q_seguidora)
        beneficios_seguidora.append(beneficio_seguidora)
        cantidad_total = q_seguidora + sol
        cantidades_total.append(cantidad_total)
        precio = a - b*cantidad_total
        precios.append(precio)
        excedente = ((a-precio)*cantidad_total)/2
        excedentes.append(excedente)
        beneficio_social = beneficio_lider + beneficio_seguidora + excedente
        beneficios_sociales.append(beneficio_social)

      fila_resultado = {'valor_a3': a3, 'valor_b': b}

      for idx, cant_lider in enumerate(soluciones):
        fila_resultado[f'q_lider{idx + 1}'] = cant_lider

      for idx, cant_seguidora in enumerate(cantidades_seguidora):
        fila_resultado[f'q_segudiora{idx + 1}'] = cant_seguidora

      for idx, benef_lider in enumerate(beneficios_lider):
        fila_resultado[f'beneficio_lider{idx + 1}'] = benef_lider

      for idx, benef_seguidora in enumerate(beneficios_seguidora):
        fila_resultado[f'beneficio_seguidora{idx + 1}'] = benef_seguidora

      for idx, cant_total in enumerate(cantidades_total):
        fila_resultado[f'cantidad_total{idx + 1}'] = cant_total

      for idx, precio in enumerate(precios):
        fila_resultado[f'precio{idx + 1}'] = precio

      for idx, excedente in enumerate(excedentes):
        fila_resultado[f'excedente{idx + 1}'] = excedente

      for idx, bS in enumerate(beneficios_sociales):
        fila_resultado[f'beneficios_sociales{idx + 1}'] = bS

      resultados_stackelberg.append(fila_resultado)

df_resultados_stackelberg_PB = pd.DataFrame(resultados_stackelberg)
df_resultados_stackelberg_PB

df_resultados_stackelberg_PB.to_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/stackelberg_PB_a3(0.1-5-0.1)_b(50-200-5).xlsx')

"""### **SEGUNDO BUCLE**

El parámetro $a_3$ tomará valores en el rango $[5, 10)$ con incrementos de $0.1$ y el parámetro $b$ tomará valores en el rango $[5, 100)$ con incrementos de $5$.
"""

resultados_stackelberg = []

for a3 in np.arange(5, 10, 0.1):
  for b in np.arange(5, 100, 5):

      beneficio_L_2_reemp_D_mod = beneficio_L_2_reemp_D.subs('a3', a3).subs('b', b)
      soluciones = sp.solve(beneficio_L_2_reemp_D_mod, qL)
      #print(soluciones)

      for solucion in soluciones:

        beneficio_L_2_reemp_DD_mod = beneficio_L_2_reemp_DD.subs('a3', a3).subs('b', b).subs('qL',solucion)

        if solucion < 0:
          soluciones.remove(solucion)

        elif solucion.is_real == False:
          soluciones.remove(solucion)

        elif beneficio_L_2_reemp_DD_mod > 0:
          soluciones.remove(solucion)

      cantidades_seguidora = []
      beneficios_lider = []
      beneficios_seguidora = []
      cantidades_total = []
      precios = []
      excedentes = []
      beneficios_sociales = []

      for sol in soluciones:
        q_seguidora = f_reaccion_S.subs('a3', a3).subs('b', b).subs('qL',sol)
        cantidades_seguidora.append(q_seguidora)
        beneficio_lider = beneficio_L_2_reemp.subs('a3', a3).subs('b', b).subs('qL',sol)
        beneficios_lider.append(beneficio_lider)
        beneficio_seguidora = beneficio_S_2.subs('a3', a3).subs('b', b).subs('qL',sol).subs('qS', q_seguidora)
        beneficios_seguidora.append(beneficio_seguidora)
        cantidad_total = q_seguidora + sol
        cantidades_total.append(cantidad_total)
        precio = a - b*cantidad_total
        precios.append(precio)
        excedente = ((a-precio)*cantidad_total)/2
        excedentes.append(excedente)
        beneficio_social = beneficio_lider + beneficio_seguidora + excedente
        beneficios_sociales.append(beneficio_social)

      fila_resultado = {'valor_a3': a3, 'valor_b': b}

      for idx, cant_lider in enumerate(soluciones):
        fila_resultado[f'q_lider{idx + 1}'] = cant_lider

      for idx, cant_seguidora in enumerate(cantidades_seguidora):
        fila_resultado[f'q_segudiora{idx + 1}'] = cant_seguidora

      for idx, benef_lider in enumerate(beneficios_lider):
        fila_resultado[f'beneficio_lider{idx + 1}'] = benef_lider

      for idx, benef_seguidora in enumerate(beneficios_seguidora):
        fila_resultado[f'beneficio_seguidora{idx + 1}'] = benef_seguidora

      for idx, cant_total in enumerate(cantidades_total):
        fila_resultado[f'cantidad_total{idx + 1}'] = cant_total

      for idx, precio in enumerate(precios):
        fila_resultado[f'precio{idx + 1}'] = precio

      for idx, excedente in enumerate(excedentes):
        fila_resultado[f'excedente{idx + 1}'] = excedente

      for idx, bS in enumerate(beneficios_sociales):
        fila_resultado[f'beneficios_sociales{idx + 1}'] = bS

      resultados_stackelberg.append(fila_resultado)

df_resultados_stackelberg_SB = pd.DataFrame(resultados_stackelberg)
df_resultados_stackelberg_SB

df_resultados_stackelberg_SB.to_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/stackelberg_a3(5-10-0.1)_b(5-100-5).xlsx')

"""### **TERCER BUCLE**

El parámetro $a_3$ tomará valores en el rango $[100, 150)$ con incrementos de $0.1$ y el parámetro $b$ tomará valores en el rango $[1000, 10000)$ con incrementos de $20$.
"""

resultados_stackelberg = []

for a3 in np.arange(100, 150, 0.5):
  for b in np.arange(1000, 1200, 10):

      beneficio_L_2_reemp_D_mod = beneficio_L_2_reemp_D.subs('a3', a3).subs('b', b)
      soluciones = sp.solve(beneficio_L_2_reemp_D_mod, qL)
      #print(soluciones)

      for solucion in soluciones:

        beneficio_L_2_reemp_DD_mod = beneficio_L_2_reemp_DD.subs('a3', a3).subs('b', b).subs('qL',solucion)

        if solucion < 0:
          soluciones.remove(solucion)

        elif solucion.is_real == False:
          soluciones.remove(solucion)

        elif beneficio_L_2_reemp_DD_mod > 0:
          soluciones.remove(solucion)

      cantidades_seguidora = []
      beneficios_lider = []
      beneficios_seguidora = []
      cantidades_total = []
      precios = []
      excedentes = []
      beneficios_sociales = []

      for sol in soluciones:
        q_seguidora = f_reaccion_S.subs('a3', a3).subs('b', b).subs('qL',sol)
        cantidades_seguidora.append(q_seguidora)
        beneficio_lider = beneficio_L_2_reemp.subs('a3', a3).subs('b', b).subs('qL',sol)
        beneficios_lider.append(beneficio_lider)
        beneficio_seguidora = beneficio_S_2.subs('a3', a3).subs('b', b).subs('qL',sol).subs('qS', q_seguidora)
        beneficios_seguidora.append(beneficio_seguidora)
        cantidad_total = q_seguidora + sol
        cantidades_total.append(cantidad_total)
        precio = a - b*cantidad_total
        precios.append(precio)
        excedente = ((a-precio)*cantidad_total)/2
        excedentes.append(excedente)
        beneficio_social = beneficio_lider + beneficio_seguidora + excedente
        beneficios_sociales.append(beneficio_social)

      fila_resultado = {'valor_a3': a3, 'valor_b': b}

      for idx, cant_lider in enumerate(soluciones):
        fila_resultado[f'q_lider{idx + 1}'] = cant_lider

      for idx, cant_seguidora in enumerate(cantidades_seguidora):
        fila_resultado[f'q_segudiora{idx + 1}'] = cant_seguidora

      for idx, benef_lider in enumerate(beneficios_lider):
        fila_resultado[f'beneficio_lider{idx + 1}'] = benef_lider

      for idx, benef_seguidora in enumerate(beneficios_seguidora):
        fila_resultado[f'beneficio_seguidora{idx + 1}'] = benef_seguidora

      for idx, cant_total in enumerate(cantidades_total):
        fila_resultado[f'cantidad_total{idx + 1}'] = cant_total

      for idx, precio in enumerate(precios):
        fila_resultado[f'precio{idx + 1}'] = precio

      for idx, excedente in enumerate(excedentes):
        fila_resultado[f'excedente{idx + 1}'] = excedente

      for idx, bS in enumerate(beneficios_sociales):
        fila_resultado[f'beneficios_sociales{idx + 1}'] = bS

      resultados_stackelberg.append(fila_resultado)

df_resultados_stackelberg_TB = pd.DataFrame(resultados_stackelberg)

df_resultados_stackelberg_TB

df_resultados_stackelberg_TB.to_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/stackelberg_TB_a3(100-150-0.5)_b(1000-1200-10).xlsx')

"""## **Conclusiones**

Para cada uno de los bucles, vamos a importar, desde excel, los datos generados anteriormente.

Vamos a generar un DataFrame, para cada bucle, que represente la diferencia en los beneficios sociales entre dos escenarios: con RIGI (Stackelberg) y sin RIGI (Cournot). Para ello, al beneficio social en el escenario con RIGI le restaremos el beneficio social en el escenario sin RIGI. Además, a esta diferencia le descontaremos un valor fijo de 2, que representa el costo de la inversión de la empresa que accede al RIGI. Este costo se asume como una perpetuidad de la inversión realizada en el primer período.

### **Primer BUCLE**
"""

df_resultados_cournot_PB = pd.read_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/cournot_PB_a3(0.1-5-0.1)_b(50-200-5).xlsx', index_col = 0)
df_resultados_stackelberg_PB = pd.read_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/stackelberg_PB_a3(0.1-5-0.1)_b(50-200-5).xlsx', index_col = 0)

df_resultados_cournot_PB = df_resultados_cournot_PB.rename(columns={"valor_a3": "Valor a3", "valor_b": "Valor b"})
df_resultados_stackelberg_PB = df_resultados_stackelberg_PB.rename(columns={"valor_a3": "Valor a3", "valor_b": "Valor b", "q_lider1": "Cantidad Lider (RIGI)", "q_segudiora1": "Cantidad Seguidora (RIGI)", "beneficio_lider1": "Beneficio Lider (RIGI)", "beneficio_seguidora1": "Beneficio Seguidora (RIGI)", "cantidad_total1": "Cantidad Total (RIGI)", "precio1": "Precio (RIGI)", "excedente1": "Excedente del Consumidor (RIGI)", "beneficios_sociales1": "Beneficio Social (RIGI)"})

df_compuesto_PB = df_resultados_stackelberg_PB[['Valor a3', 'Valor b', 'Beneficio Social (RIGI)']]
df_compuesto_PB = df_compuesto_PB.merge(df_resultados_cournot_PB[['Valor a3', 'Valor b', 'Beneficio Social']],
                            on=['Valor a3', 'Valor b'],
                            how='left')
df_compuesto_PB['Diferencia de BS'] = df_compuesto_PB['Beneficio Social (RIGI)'] - df_compuesto_PB['Beneficio Social'] - 2
df_rigi_PB = df_compuesto_PB[['Valor a3', 'Valor b', 'Beneficio Social (RIGI)', 'Beneficio Social', 'Diferencia de BS']]
df_rigi_PB

colores = ['green' if x > 0 else 'red' for x in df_rigi_PB['Diferencia de BS']]

plt.figure(figsize=(10, 6))
plt.scatter(df_rigi_PB.index, df_rigi_PB['Diferencia de BS'], c=colores)

plt.xlabel('Índice')
plt.ylabel('Diferencia de Beneficios Sociales')
plt.title('Diferencia de Beneficios Sociales')

plt.show()

# Crear colores basados en la diferencia de beneficio
colors = df_rigi_PB['Diferencia de BS'].apply(lambda x: 'green' if x > 0 else 'red')

# Crear el scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(df_rigi_PB['Valor a3'], df_rigi_PB['Valor b'], c=colors, s=40, edgecolor='white', alpha=0.9)

# Añadir etiquetas y título
plt.xlabel('Valor a3', fontsize=12)
plt.ylabel('Valor b', fontsize=12)
plt.title('Diferencia entre Beneficios Sociales', fontsize=14)
plt.axhline(0, color='gray', linestyle='--', linewidth=0.5)  # Línea horizontal en y=0 para referencia
plt.axvline(0, color='gray', linestyle='--', linewidth=0.5)  # Línea vertical en x=0 para referencia

# Mostrar el gráfico
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

plt.figure(figsize=(8, 6))
scatter = plt.scatter(df_rigi_PB['Valor a3'], df_rigi_PB['Valor b'],
                      c=df_rigi_PB['Diferencia de BS'], cmap='viridis',
                      s=40, edgecolor='k')

plt.colorbar(scatter, label='Diferencia BS')
plt.xlabel('Valor a3')
plt.ylabel('Valor b')
plt.title('Diferencia entre Beneficios Sociales')

# Definir valores de referencia en los ejes
x_min, x_max = df_rigi_PB['Valor a3'].min(), df_rigi_PB['Valor a3'].max()
y_min, y_max = df_rigi_PB['Valor b'].min(), df_rigi_PB['Valor b'].max()

x_ticks = np.linspace(x_min, x_max, num=5)  # 5 valores en el eje X
y_ticks = np.linspace(y_min, y_max, num=5)  # 5 valores en el eje Y

plt.xticks(x_ticks.round(2))  # Redondear para mejor legibilidad
plt.yticks(y_ticks.round(2))

plt.grid()
plt.gca().spines[['top', 'right']].set_visible(False)  # Ocultar bordes superiores y derechos

plt.show()

# Redondear los valores para hacerlos discretos (opcional)
df_rigi_PB['Valor a3'] = pd.cut(df_rigi_PB['Valor a3'], bins=5, labels=False)
df_rigi_PB['Valor b'] = pd.cut(df_rigi_PB['Valor b'], bins=5, labels=False)

# Crear una tabla cruzada
heatmap_data = df_rigi_PB.pivot_table(values='Diferencia de BS', index='Valor a3', columns='Valor b', aggfunc='mean')

# Crear heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(heatmap_data, annot=True, cmap='coolwarm', fmt=".2f", cbar_kws={'label': 'Diferencia de BS'})
plt.xlabel('Valor a3')
plt.ylabel('Valor b')
plt.title('Diferencia de Beneficios Sociales (BS Stackelberg - BS Cournot)')
plt.show()

fig = plt.figure(figsize=(8, 6))  # Aumentar tamaño
ax = fig.add_subplot(111, projection='3d')

ax.scatter(df_rigi_PB['Valor a3'], df_rigi_PB['Valor b'], df_rigi_PB['Diferencia de BS'],
           c=df_rigi_PB['Diferencia de BS'], cmap='viridis', s=50)

ax.set_xlabel('Valor a3', labelpad=20)  # Aumenta la distancia del label del eje X
ax.set_ylabel('Valor b', labelpad=15)   # Aumenta la distancia del label del eje Y
ax.set_zlabel('Diferencia de BS', labelpad=25)  # Aumenta la distancia del label del eje Z
ax.set_title('Diferencia de Beneficios Sociales en función de a3 y b')

# plt.tight_layout()  # Ajustar automáticamente los márgenes
plt.show()

"""### **Segundo BUCLE**"""

df_resultados_cournot_SB = pd.read_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/cournot_SB_a3(5-10-0.1)_b(5-100-5).xlsx', index_col = 0)
df_resultados_stackelberg_SB = pd.read_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/stackelberg_SB_a3(5-10-0.1)_b(5-100-5).xlsx', index_col = 0)

df_resultados_cournot_SB = df_resultados_cournot_SB.rename(columns={"valor_a3": "Valor a3", "valor_b": "Valor b"})
df_resultados_stackelberg_SB = df_resultados_stackelberg_SB.rename(columns={"valor_a3": "Valor a3", "valor_b": "Valor b", "q_lider1": "Cantidad Lider (RIGI)", "q_segudiora1": "Cantidad Seguidora (RIGI)", "beneficio_lider1": "Beneficio Lider (RIGI)", "beneficio_seguidora1": "Beneficio Seguidora (RIGI)", "cantidad_total1": "Cantidad Total (RIGI)", "precio1": "Precio (RIGI)", "excedente1": "Excedente del Consumidor (RIGI)", "beneficios_sociales1": "Beneficio Social (RIGI)"})

df_compuesto_SB = df_resultados_stackelberg_SB[['Valor a3', 'Valor b', 'Beneficio Social (RIGI)']]
df_compuesto_SB = df_compuesto_SB.merge(df_resultados_cournot_SB[['Valor a3', 'Valor b', 'Beneficio Social']],
                            on=['Valor a3', 'Valor b'],
                            how='left')
df_compuesto_SB['Diferencia de BS'] = df_compuesto_SB['Beneficio Social (RIGI)'] - df_compuesto_SB['Beneficio Social'] - 2
df_rigi_SB = df_compuesto_SB[['Valor a3', 'Valor b', 'Beneficio Social (RIGI)', 'Beneficio Social', 'Diferencia de BS']]
df_rigi_SB

colores = ['green' if x > 0 else 'red' for x in df_rigi_SB['Diferencia de BS']]

plt.figure(figsize=(10, 6))
plt.scatter(df_rigi_SB.index, df_rigi_SB['Diferencia de BS'], c=colores)

plt.xlabel('Índice')
plt.ylabel('Diferencia de Beneficios Sociales')
plt.title('Diferencia de Beneficios Sociales')

plt.show()

# Crear colores basados en la diferencia de beneficio
colors = df_rigi_SB['Diferencia de BS'].apply(lambda x: 'green' if x > 0 else 'red')

# Crear el scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(df_rigi_SB['Valor a3'], df_rigi_SB['Valor b'], c=colors, s=40, edgecolor='white', alpha=0.9)

# Ajustar automáticamente los ejes
plt.xlim(df_rigi_SB['Valor a3'].min() - 1, df_rigi_SB['Valor a3'].max() + 1)
plt.ylim(df_rigi_SB['Valor b'].min() - 3, df_rigi_SB['Valor b'].max() + 3)

# Añadir etiquetas y título
plt.xlabel('Valor a3', fontsize=12)
plt.ylabel('Valor b', fontsize=12)
plt.title('Diferencia entre Beneficios Sociales', fontsize=14)

# Líneas de referencia en los ejes
plt.axhline(0, color='gray', linestyle='--', linewidth=0.5)
plt.axvline(0, color='gray', linestyle='--', linewidth=0.5)

# Mostrar el gráfico
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

plt.figure(figsize=(8, 6))
scatter = plt.scatter(df_rigi_SB['Valor a3'], df_rigi_SB['Valor b'],
                      c=df_rigi_SB['Diferencia de BS'], cmap='viridis',
                      s=40, edgecolor='k')

plt.colorbar(scatter, label='Diferencia BS')
plt.xlabel('Valor a3')
plt.ylabel('Valor b')
plt.title('Diferencia entre Beneficios Sociales')

# Definir valores de referencia en los ejes
x_min, x_max = df_rigi_SB['Valor a3'].min(), df_rigi_SB['Valor a3'].max()
y_min, y_max = df_rigi_SB['Valor b'].min(), df_rigi_SB['Valor b'].max()

x_ticks = np.linspace(x_min, x_max, num=5)  # 5 valores en el eje X
y_ticks = np.linspace(y_min, y_max, num=5)  # 5 valores en el eje Y

plt.xticks(x_ticks.round(2))  # Redondear para mejor legibilidad
plt.yticks(y_ticks.round(2))

plt.grid()
plt.gca().spines[['top', 'right']].set_visible(False)  # Ocultar bordes superiores y derechos

plt.show()

# Redondear los valores para hacerlos discretos (opcional)
df_rigi_SB['Valor a3'] = pd.cut(df_rigi_SB['Valor a3'], bins=5, labels=False)
df_rigi_SB['Valor b'] = pd.cut(df_rigi_SB['Valor b'], bins=5, labels=False)

# Crear una tabla cruzada
heatmap_data = df_rigi_SB.pivot_table(values='Diferencia de BS', index='Valor a3', columns='Valor b', aggfunc='mean')

# Crear heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(heatmap_data, annot=True, cmap='coolwarm', fmt=".2f", cbar_kws={'label': 'Diferencia de BS'})
plt.xlabel('Valor a3')
plt.ylabel('Valor b')
plt.title('Diferencia de Beneficios Sociales (BS Stackelberg - BS Cournot)')
plt.show()

fig = plt.figure(figsize=(8, 6))  # Aumentar tamaño
ax = fig.add_subplot(111, projection='3d')

ax.scatter(df_rigi_SB['Valor a3'], df_rigi_SB['Valor b'], df_rigi_SB['Diferencia de BS'],
           c=df_rigi_SB['Diferencia de BS'], cmap='viridis', s=50)

ax.set_xlabel('Valor a3', labelpad=20)  # Aumenta la distancia del label del eje X
ax.set_ylabel('Valor b', labelpad=15)   # Aumenta la distancia del label del eje Y
ax.set_zlabel('Diferencia de BS', labelpad=25)  # Aumenta la distancia del label del eje Z
ax.set_title('Diferencia de Beneficios Sociales en función de a3 y b')

plt.tight_layout()  # Ajustar automáticamente los márgenes
plt.show()

"""### **Tercer BUCLE**

"""

df_resultados_cournot_TB = pd.read_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/cournot_TB_a3(100-150-0.1)_b(1000-1200-10).xlsx', index_col = 0)
df_resultados_stackelberg_TB = pd.read_excel('/content/drive/MyDrive/Profesional/Licenciatura en Economía/TESIS/EXCEL/stackelberg_TB_a3(100-150-0.5)_b(1000-1200-10).xlsx', index_col = 0)

df_resultados_cournot_TB = df_resultados_cournot_TB.rename(columns={"valor_a3": "Valor a3", "valor_b": "Valor b"})
df_resultados_stackelberg_TB = df_resultados_stackelberg_TB.rename(columns={"valor_a3": "Valor a3", "valor_b": "Valor b", "q_lider1": "Cantidad Lider (RIGI)", "q_segudiora1": "Cantidad Seguidora (RIGI)", "beneficio_lider1": "Beneficio Lider (RIGI)", "beneficio_seguidora1": "Beneficio Seguidora (RIGI)", "cantidad_total1": "Cantidad Total (RIGI)", "precio1": "Precio (RIGI)", "excedente1": "Excedente del Consumidor (RIGI)", "beneficios_sociales1": "Beneficio Social (RIGI)"})

df_compuesto_TB = df_resultados_stackelberg_TB[['Valor a3', 'Valor b', 'Beneficio Social (RIGI)']]
df_compuesto_TB = df_compuesto_TB.merge(df_resultados_cournot_TB[['Valor a3', 'Valor b', 'Beneficio Social']],
                            on=['Valor a3', 'Valor b'],
                            how='left')

df_compuesto_TB['Beneficio Social'] = df_compuesto_TB['Beneficio Social'].fillna(0)
df_compuesto_TB['Diferencia de BS'] = df_compuesto_TB['Beneficio Social (RIGI)'] - df_compuesto_TB['Beneficio Social'] - 2

df_rigi_TB = df_compuesto_TB[['Valor a3', 'Valor b', 'Beneficio Social (RIGI)', 'Beneficio Social', 'Diferencia de BS']]
df_rigi_TB

colores = ['green' if x > 0 else 'red' for x in df_rigi_TB['Diferencia de BS']]

plt.figure(figsize=(10, 6))
plt.scatter(df_rigi_TB.index, df_rigi_TB['Diferencia de BS'], c=colores)

plt.xlabel('Índice')
plt.ylabel('Diferencia de Beneficios Sociales')
plt.title('Diferencia de Beneficios Sociales')

plt.show()

# Crear colores basados en la diferencia de beneficio
colors = df_rigi_TB['Diferencia de BS'].apply(lambda x: 'green' if x > 0 else 'red')

# Crear el scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(df_rigi_TB['Valor a3'], df_rigi_TB['Valor b'], c=colors, s=40, edgecolor='white', alpha=0.9)

# Ajustar automáticamente los ejes
plt.xlim(df_rigi_TB['Valor a3'].min() - 2, df_rigi_TB['Valor a3'].max() + 5)
plt.ylim(df_rigi_TB['Valor b'].min() - 2, df_rigi_TB['Valor b'].max() + 5)

# Añadir etiquetas y título
plt.xlabel('Valor a3', fontsize=12)
plt.ylabel('Valor b', fontsize=12)
plt.title('Diferencia entre Beneficios Sociales', fontsize=14)

# Líneas de referencia en los ejes
plt.axhline(0, color='gray', linestyle='--', linewidth=0.5)
plt.axvline(0, color='gray', linestyle='--', linewidth=0.5)

# Mostrar el gráfico
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

plt.figure(figsize=(8, 6))
scatter = plt.scatter(df_rigi_TB['Valor a3'], df_rigi_TB['Valor b'], c=df_rigi_TB['Diferencia de BS'], cmap='viridis', s=40, edgecolor='k')
plt.colorbar(scatter, label='Diferencia BS')
plt.xlabel('Valor a3')
plt.ylabel('Valor b')
plt.title('Diferencia entre Beneficios Sociales')
plt.grid()
plt.xticks([])  # Ocultar líneas y etiquetas del eje X
plt.yticks([])  # Ocultar líneas y etiquetas del eje Y
plt.gca().spines[['top', 'right', 'left', 'bottom']].set_visible(False)  # Ocultar bordes
plt.show()

# Redondear los valores para hacerlos discretos (opcional)
df_rigi_TB['Valor a3'] = pd.cut(df_rigi_TB['Valor a3'], bins=5, labels=False)
df_rigi_TB['Valor b'] = pd.cut(df_rigi_TB['Valor b'], bins=5, labels=False)

# Crear una tabla cruzada
heatmap_data = df_rigi_TB.pivot_table(values='Diferencia de BS', index='Valor a3', columns='Valor b', aggfunc='mean')

# Crear heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(heatmap_data, annot=True, cmap='coolwarm', fmt=".2f", cbar_kws={'label': 'Diferencia de BS'})
plt.xlabel('Valor a3')
plt.ylabel('Valor b')
plt.title('Diferencia de Beneficios Sociales (BS Stackelberg - BS Cournot)')
plt.show()

fig = plt.figure(figsize=(8, 6))  # Aumentar tamaño
ax = fig.add_subplot(111, projection='3d')

ax.scatter(df_rigi_TB['Valor a3'], df_rigi_TB['Valor b'], df_rigi_TB['Diferencia de BS'],
           c=df_rigi_TB['Diferencia de BS'], cmap='viridis', s=50)

ax.set_xlabel('Valor a3', labelpad=20)  # Aumenta la distancia del label del eje X
ax.set_ylabel('Valor b', labelpad=15)   # Aumenta la distancia del label del eje Y
ax.set_zlabel('Diferencia de BS', labelpad=25)  # Aumenta la distancia del label del eje Z
ax.set_title('Diferencia de Beneficios Sociales en función de a3 y b')

plt.tight_layout()  # Ajustar automáticamente los márgenes
plt.show()
